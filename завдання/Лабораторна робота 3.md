
Для всіх задач слід написати тести з використанням бібліотеки `unittest`.  Ваш проект має бути розділено на окремі папки для коду додатку та тестів (`src` та `test` відповідно).

При написанні коду дотримуйтесь стандарту PEP 8, який визначає правила форматування Python-коду, такі як відступи, довжина рядків, іменування змінних тощо. Для полегшення читабельності коду слід відформатувати ваш код з допомогою  `Black` 

## Рівень 1
### Варіант 1
Існує три найпоширеніші способи проходження бінарних дерев вглиб: **прямий (pre-order), зворотній (post-order) та серединний (in-order)**.

Реалізуйте функцію, яка отримує на вхід вершину бінарного дерева та виконує його зворотній обхід (pre-order traversal) та повертає значення вузлів у списку у відповідному порядку.

Розглянемо таке бінарне дерево:

```
    1
   / \
  2    3
   \  / \
   5  6  7
```
Під час прямого обходу це дерево буде відвідане в такому порядку: `[1, 2, 5, 3, 6, 7]`

Функція `pre_order_traversal(root: BinaryTree) -> List` отримує на вхід корінь бінарного дерева, який має наступний вигляд:
```
class BinaryTree:
    def __init__(self, value, left=None, right=None, parent=None):
        self.value = value
        self.left = left
        self.right = right
```

Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу `BinaryTree` наступним чином:

```
root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)
```

### Варіант 2

Існує три найпоширеніші способи проходження бінарних дерев вглиб: **прямий (pre-order), зворотній (post-order) та серединний (in-order)**.

Реалізуйте функцію, яка отримує на вхід вершину бінарного дерева та виконує його зворотній обхід (Post-order traversal) та повертає значення вузлів у списку у відповідному порядку.

Розглянемо таке бінарне дерево:

```
    1
   / \
  2    3
   \  / \
   5  6  7
```
Під час прямого обходу це дерево буде відвідане в такому порядку: `[5, 2, 6, 7, 3, 1]`

Функція `post_order_traversal(root: BinaryTree) -> List` отримує на вхід корінь бінарного дерева, який має наступний вигляд:
```
class BinaryTree:
    def __init__(self, value, left=None, right=None, parent=None):
        self.value = value
        self.left = left
        self.right = right
```

Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу `BinaryTree` наступним чином:

```
root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)
```
### Варіант 3

Існує три найпоширеніші способи проходження бінарних дерев вглиб: **прямий (pre-order), зворотній (post-order) та серединний (in-order)**.

Реалізуйте функцію, яка отримує на вхід вершину бінарного дерева та виконує його серединний обхід (in-order traversal) та повертає значення вузлів у списку у відповідному порядку.

Розглянемо таке бінарне дерево:

```
    1
   / \
  2    3
   \  / \
   5  6  7
```
Під час серединного обходу це дерево буде відвідане в такому порядку: `[2, 5, 1, 6, 7, 3]`

Функція `in_order_traversal(root: BinaryTree) -> List` отримує на вхід корінь бінарного дерева, який має наступний вигляд:
```
class BinaryTree:
    def __init__(self, value, left=None, right=None, parent=None):
        self.value = value
        self.left = left
        self.right = right
```

Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу `BinaryTree` наступним чином:

```
root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)
```

## Рівень 2
### Варіант 1

Для бінарного дерева знайдіть суму всіх листків, які є лівими дітьми.

```
    3
   / \
  9  20
    /  \
   15   7
```
Лівий лист цього дерева - 9 та 15, тому сума лівих листів становить 9 + 15 = 24.

Реалізуйте функцію, яка отримує на вхід кореневий вузол дерева, та повертає значення суми `branchSums`: 
```
def branchSums(root):
	pass
```
**Вхідні дані:** Дерево подається у вигляді вузлів, де кожен вузол має ціле значення. Корінь дерева завжди не є лівим листом

Клас, який описує бінарне дерево (та будь який вузол дерева) має вигляд:

```
class BinaryTree:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
```

Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу `BinaryTree` наступним чином:

```
root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)
```

**Вихідні дані:** Сума всіх лівих листів у бінарному дереві.

### Варіант 2

Для бінарного дерева знайдіть суму всіх глибин усіх вузлів. Глибина вузла - це кількість ребер, які потрібно пройти від кореня дерева, щоб досягти цього вузла.

Ваше завдання полягає в написанні функції, яка обчислює та повертає суми глибин для всіх вузлів у бінарному дереві

**Приклад:** Розглянемо таке бінарне дерево:

```
    1
   / \
  2   3
 / \
4   5
```

Глибина вузла `1` -`0`, глибина вузла `2` та `3`  становить `1`, а глибина вузлів `4` та `5` - `2`. Сума глибин всіх вузлів дорівнює `0 + 1 + 1 + 2 + 2 = 6`.

Функція отримує на вхід корінь бінарного дерева, який має наступний вигляд:

```
class TreeNode:
    def __init__(self, value=0, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

```

 Ваша функція має мати такий вигляд:
 
```
def sum_of_depths(root: TreeNode) -> int:
    # ваш код
```

Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу `TreeNode` наступним чином:

```
root = TreeNode(3)
root.left = TreeNode(9)
root.right = TreeNode(20)
```

### Варіант 3

Напишіть функцію, яка виконає операцію інвертування (перевернення) бінарного дерева таким чином, щоб лівий дочірній вузол став правим, а правий дочірній вузол став лівим.

Нехай у вас задане бінарне дерево такого вигляду:

```
    1
   / \
  2   3
 / \ / \
4  5 6  7
```

Ваша функція має повернути дерево, яке виглядатиме наступним чином:
```
    1
   / \
  3   2
 / \ / \
7  6 5  4
```

Клас, який описує бінарне дерево (та будь який вузол дерева) має вигляд:
```
# This is the class of the input binary tree.
class BinaryTree:
    def __init__(self, value: int):
        self.value = value
        self.left = None
        self.right = None
```

Ваша функція має мати такий вигляд:

```
def invert_binary_tree(tree) -> BinaryTree:
```


Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу `BinaryTree` наступним чином:

```
root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)
```

Ваша функція має повернути об'єкт класу  `BinaryTree`. Для спрощення тестування даної функції достатньо реалізувати порівняння значень вузлів дерева

## Рівень 3

### Варіант 1
Для заданого бінарного дерева та конкретної вершини в цьому дереві реалізуйте функцію пошуку наступного елемента під час серединного проходу (in-order traversal). Наступник - це вузол, який має значення більше за заданий вузол і знаходиться найближче до нього при серединному обході.

Нехай у вас задане бінарне дерево такого вигляду:
```
    10
   /  \
  5    15
 / \     \
3   7    20
         /
        12

```
Для вершини зі значенням 7, наступник - це вузол зі значенням 10.

Функція отримує на вхід корінь бінарного дерева та вершину, для якої потрібно знайти наступника.

Клас, який описує бінарне дерево (та будь який вузол дерева) має вигляд:
```
# This is the class of the input binary tree.
class BinaryTree:
    def __init__(self, value, left=None, right=None, parent=None):
        self.value = value
        self.left = left
        self.right = right
        self.parent = parent
```

Ваша функція має мати такий вигляд:

```
def find_successor(tree: BinaryTree, node: BinaryTree) -> BinaryTree:
```

Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу `BinaryTree` наступним чином:

```
root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)
```
### Варіант 2

Для заданого бінарного дерева перевірте, чи воно є збалансованим деревом. Бінарне дерево вважається збалансованим, якщо різниця у висоті його лівого та правого піддерев не перевищує 1 для будь-якого піддерева.

Розглянемо таке бінарне дерево:
```
    1
   / \
  2   3
 / \     
4   5   
```

Це дерево є збалансованим, оскільки різниця висоти лівого піддерева та правого піддерева не перевищує 1.

Реалізована вами функція `is_tree_balanced(node: BinaryTree) -> bool` отримує на вхід корінь бінарного дерева та повертає `True`, якщо бінарне дерево є збалансованим, та `False`, якщо воно не збалансоване.

Клас, який описує бінарне дерево (та будь який вузол дерева) має вигляд:

```
class BinaryTree:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right
```

Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу `BinaryTree` наступним чином:

```
root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)
```

### Варіант 3

Для заданого бінарного дерева  реалізуйте функцію, яка обчислює та повертає значення максимального діаметра у бінарному дереві - найвіддаленішу відстань між двома листками. Максимальний діаметр у бінарному дереві визначає найбільшу відстань між будь-якою парою листків (кінцевих вузлів) у дереві. Діаметр вимірюється як кількість ребер, які потрібно пройти, щоб дістатися одного листка від іншого. Максимальний діаметр не обов'язково має включати в себе кореневий вузол 

Нехай у вас задане бінарне дерево такого вигляду:
```
        1
       /  \
      3    2
     / \
    7   4
   /     \
  8       5
 /         \
9           6
```

Для даного дерева максимальний діаметр становить 6: `9 -> 8 -> 7 -> 3 -> 4 -> 5 -> 6` -  для проходження від листка 9 до листка 6 слід пройти 6 ребер.

Реалізована вами функція `binary_tree_diameter(tree: BinaryTree) -> int` отримує на вхід корінь бінарного дерева та повертає максимальний діаметр дерева.

Клас, який описує бінарне дерево (та будь який вузол дерева) має вигляд:

```
class BinaryTree:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right
```

Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу `BinaryTree` наступним чином:

```
root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)
```
