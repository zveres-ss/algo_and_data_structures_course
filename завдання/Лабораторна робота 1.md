
## Рівень 1

### Варіант 1
Дані два масиви цілих чисел `nums1` і `nums2`, де `nums1` є підмасивом `nums2`, якщо всі елементи `nums1` знаходяться в `nums2`, в тому ж порядку.

Напишіть функцію `is_subarray`, яка приймає два масиви цілих чисел та повертає `True`, якщо `nums1` є підмасивом `nums2`, та `False` в іншому випадку.

Приклади
Вхідні дані: nums1 = 1,2,3, nums2 = 1,2,3,4
Результат: True
Пояснення: Всі елементи nums1 ([1,2,3]) присутні в nums2.

Вхідні дані: nums1 = [4, 2], nums2 = [1,2,3,4]
Результат: False
Пояснення: Елементи nums1 ([4, 2]) не знаходяться в тому ж порядку в nums2.

Вхідні дані: nums1 = [1,3,5], nums2 = [1,2,3,4,5]
Результат: True
Пояснення: Елементи nums1 ([1,3,5]) присутні в nums2.

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` та перевірити роботу вашої функції на прикладах, наведених вище
### Варіант 2

Дано масив цілих чисел `nums` та ціле число `target`. Перевірте, чи існують два різних елементи в масиві `nums`, сума яких дорівнює `target`. Якщо такі елементи існують, поверніть індекси цих елементів.

Припустимо, що кожен масив цілих чисел `nums` може мати більше одного рішення, або жодного, і той самий елемент не може бути використаний двічі. Якщо масив не містить двох чисел, сума яких рівна `target` - тоді слід повернути значення `-1`

Приклади:

Вхідні дані: `nums = [2,7,11,15], target = 9`
Результат: `[0,1]`
Пояснення: Елементи `nums [0]` + `nums[1]` = 2 + 7 = 9, їх сума рівна target.

Вхідні дані: `nums = [3,2,4], target = 6`
Результат: `[1,2]`
Пояснення: Елементи `nums[1]` + `nums[2]` = 2 + 4 = 6, їх сума рівна target.

Вхідні дані: `nums = [3,3], target = 6`
Результат: `[0,1]`
Пояснення: Елементи `nums[0]` + `nums[1]` = 3 + 3 = 6, їх сума рівна target.

Вхідні дані: `nums = [3,5], target = 6`
Результат:  -1
Пояснення: Немає елементів, сума яких рівна target.

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` та перевірити роботу вашої функції на прикладах, наведених вище
### Варіант 3


Дано відсортований масив цілих чисел `nums` за зростанням (від менших до більших значень). Напишіть функцію, яка повертає новий масив, в якому кожен елемент є квадратом відповідного елемента з масиву `nums`. Отриманий масив також повинен бути відсортованим за зростанням.

Поверніть новий масив відповідно до вхідних даних.

Вхідні дані: nums = [-4,-2,0,1,3]
Результат: [0,1,4,9,16]

Вхідні дані: nums = [1,2,3,4,5]
Результат: [1,4,9,16,25]

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` та перевірити роботу вашої функції на прикладах, наведених вище
## Рівень 2.

### Варіант 1

Зеник подарував Марічці ділянку городу розміром n на m, поділену на клітинки розміром 1 на 1 метр. У кожній клітинці Марічка посадила гарбузи, щоб дарувати їх залицальникам. Марічка почала садити гарбузи починаючи із верхньої лівої, і при досягненні правої межі - розверталась і рухалась справа наліво, як вказано в прикладі для m x n, де m - кількість рядків, а n - кількість стовпців:

1 2 3 4 
8 7 6 5 
9 10 11 12 
16 15 14 13

Для садіння Марічка вирішила використати робота-садівника, який садить в кожну клітинку задану кількість зернят, які слід вказати як одномірний масив m x n. Якщо Марічка хоче посадити таку кількість гарбузів

1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16

Тоді роботу необхідно подати на всід таку послідовність (маршрут робота не незмінним): 

1 2 3 4 8 7 6 5 9 10 11 12 16 15 14 13

 
Реалізуйте алгоритм, який отримає на вхід масив розміром m та n, в кожній клітинці якого знаходиться бажана кількість гарбузів та поверне одномірний масив, скільки зернин має висаджувати робот при руху згідно маршруту, вказаного в цій задчі (маршрут є незмінним)

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` . Ваш тести мають перевірити роботу алгоритму при значеннях m == n == 5, m =2, n =4, n = 1, m = 6

### Варіант 2

Масив вважається монотонним, якщо всі його елементи розташовані в зростаючому або спадаючому порядку.

Завдання: Напишіть функцію, яка перевіряє, чи є заданий масив монотонним. Функція повинна повертати логічне значення True, якщо масив є монотонним, і False, якщо масив не є монотонним.

Приклад вхідних даних і результатів:

1. Для масиву `[1, 2, 3, 4, 5]` функція повертає True, оскільки всі елементи зростають монотонно.
2. Для масиву `[5, 4, 3, 2, 1]` функція повертає True, оскільки всі елементи спадають монотонно.
3. Для масиву `[1, 2, 2, 3, 2, 4]` функція повертає False, оскільки масив не є строго монотонним.

Зверніть увагу, що масив із однаковими значеннями наступного елемента вважається монотонним.

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` .

### Варіант 3
Напишіть функцію для пошуку k-того найбільшого елемента в заданому масиві цілих чисел. Параметр k задається на вхід функції і визначає порядковий номер найбільшого елемента, який потрібно знайти. Наприклад, якщо k = 1, програма повинна знайти найбільший елемент в масиві. Якщо k = 2, програма повинна знайти другий за величиною елемент, і так далі.

Умови задачі:

- Масив цілих чисел передається у вашу функцію.
- Розмір масиву повинен бути не менше k.
- Програма повинна вивести k-тий найбільший елемент і його позицію (індекс) в масиві.

Приклад введення та виведення результату:

Вхідний масив: [15, 7, 22, 9, 36, 2, 42, 18] Задане k: 3 Знайдений 3-й найбільший елемент: 22 Позиція 3-го найбільшого елемента в масиві: 2

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` .

## Рівень 3.

### Варіант 1

Потрібно написати програму для обходу двовимірного масиву розміром NxM у форматі "зігзагу". Зігзаговий обхід означає, що спочатку ми рухаємось по діагоналях масиву, пчинаючи з лівої верхньої точки.  Другим елементом буде виведено елемент, який знаходиться справа, потім  знизу і ліворуч, далі ще крок вниз і рухаємось по діагоналі знову вправо. Для масиву розміром 3x3 обхід у форматі зігзагу виглядає так (де номер у клітинці відповідає порядку її відвідин):

1 2 6
3 5 7
4 8 9

Для масиву 3 х 5 це матиме вигляд:

1  2  6   7  12
3  5  8  11  13
4  9  10 14 15

Реалізуйте алгоритм, який отримає на вхід масив розміром m та n та поверне одномірний масив з значеннями елементів вхідного масиву при обході його у порядку, зазначеному вище у задачі

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` . Ваш тести мають перевірити роботу алгоритму при значеннях m == n == 5, m =2, n =4, n = 1, m = 6, n == m == 1

### Варіант 2

Напишіть функцію, яка приймає невпорядкований масив цілих чисел і повертає діапазон індексів (початковий і кінцевий) найменшого підмасиву, який потрібно відсортувати для досягнення повного впорядкування всього масиву.

Наприклад, для вхідного масиву
1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19

Результат:
(3, 9)

Підмасив, який потрібно відсортувати для впорядкування всього масиву, починається з індексу 3 (значення 7) і закінчується на індексі 9 (значення 7).
У випадку, якщо вхідний масив відсортований, слд повернути кортеж (-1, -1)


Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` та перевірити сценарії коли: вхідний масив посортований, вхідний масив необхідно сортувати весь, масив містить лише 1 елемент. 

### Варіант 3

Напишіть функцію, яка приймає невпорядкований масив цілих чисел і повертає довжину найдовшої пікової підпослідовностію Для формування пікової підпослідовності необхідно мінімум 3 числа. Пікова підпослідовність визначається як послідовність чисел, яка починається з меншого числа, після чого наступне число строго більше попереднього, поки вони не досягнуть вершини (максимального значення у підпослідовності). Всі значення після досягнення вершини мають бути завжди меншими від попередника. Наприклад, пікова послідовність може мати вигляд:

1 7 2
Де 7 - є вершиною послідовності

1 2 3 - не є піковою послідовністю (немає лівої частки)
3 2 1 - також не є піковою полідовністю (немає правої частки)
-1 -5 -1 - теж не є піковою послідовністю (необхідно знайти вершину, а не впадину)

У масиві може бути декілька пікових підпослідовностей, необхідно знайти довжину максимальної

Приклад
Для вхідного масиву: 1, 3, 5, 4, 2, 8, 3, 7,  знайдена найдовша пікова підпослідовність має довжину 5 - 1, 3, 5, 4, 2

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` та перевірити сценарії коли: 
всі елементи масиву посортовані за зростанням, 
посортовані за спаданням, 
масив з 2х елементів, 
не містять пікових підпослідовностей, 
містять 3 пікові послідовності


## Критерії оцінювання

Варіант завдання для студента визначаться згідно формули: (остача від ділення вашого номеру в списку групи на 3) + 1. Тобто якщо у вас 4й номер у списку групи, ви обираєте 1й варіант одного з рівнів

Завдання різних рівнів оцінюються таким чином:
1й рівень: від 0 до 0.7
2й рівень: від 0 до 1
3й рівень: від 0 до 1.2

Важливо: ри виборі завдання вищого рівня, вища оцінка не гарантована. 
У випадку несамостійного виконання завдання 3ього рівня студент втрачає можливість обирати завдання 3ього рівня у наступних лабораторних роботах. 

При захисті лабораторної роботи викладач має право попросити написати додаткові тести. Захист роботи може включати розбір та написання іншої задачі такого ж рівня, яку захищає студент
